# Ch15. 타입 운영

## 15.1 매핑된 타입

하나의 타입을 기반으로 새로운 타입을 생성하는 것을 **매핑**한다고 한다.

완전히 바꾸는 개념이라기 보다 기존 타입에다가 다른 타입을 가져와서 기존 타입 속성에 대해 계산된 타입을 사용하게 만들 수 있다.

인덱스 시그니처에서 `:`을 사용한 정적 키 타입 대신 `in`을 사용해서 다른 타입을 가져와서 매핑할 수 있다.

일반적인 사례로는 아래와 같이 유니온 타입의 각 문자열 리터럴 키를 가진 객체를 생성할 때이다.

```ts
type UnionType = 'type1' | 'type2' | 'type3';

type ObjType = {
  [K in UnionType]: number;
};

/*
{
  type1: number
  type2: number
  type3: number
}

이렇게 나열해서 선언해야 하는 불편함을 줄일 수 있다.
*/
```

### 15.1.1 타입에서 매핑된 타입

존재하는 타입의 키를 매핑하도록 타입을 지시하면 새로운 타입으로 **매핑**된다.
존재하는 타입에 `keyof` 연산자를 사용하면 키를 가져올 수 있다.

원본 객체가 `SomeName`이라고 한다면 해당 객체 멤버값에 접근하기 위해서는 `SomeName[K]`로 가능하다.

이것을 `keyof`연산자를 통해 `[K in keyof SomeName]`으로 매핑할 수 있다.

타입 매핑을 통해 각 객체 타입에 추가적인 타입을 유니온으로 추가할 때 사용이 가능하다.

하나의 멤버 집합을 정의하고 필요한만큼 다른 버전을 생성해낼 수 있다.

#### 매핑된 타입과 시그니처

기존 인터페이스 멤버를 함수로 선언하는 데에는 두 가지 방법이 있다.

1. `member(): void`<br>
   인터페이스의 멤버가 객체의 멤버로 호출

2. `member : () => void`<br>
   인터페이스의 멤버가 독립적인 함수로 선언

타입을 매핑할 때는 위와 같은 구분 없이 기존 타입의 속성을 그대로 사용한다.

```ts
interface 원래인터페이스 {
  메서드(): void;
  속성함수: () => string;
}

type 속성의타입만가져오는매핑<T> = {
  [K in keyof T]: T[K];
};

type 인터페이스매핑한속성 = 속성의타입만가져오는매핑<원래인터페이스>;

/*
{
  메서드 : () => void
  속성함수 : () => string
}
*/
```

실제로 클래스 타입을 갖는 매핑된 타입을 사용하는 것은 드물다.
메서드와 속성의 차이를 크게 구분하지 않기 때문에 일단 알아두기만 하자.

### 15.1.2 제한자 변경

`readonly`와 `?`와 같은 접근 제어 제한자도 매핑을 통해 각 속성의 멤버에 대해서 적용이 가능하다.

두 접근 제어자를 함께 적용도 가능하다.

기존에 적용된 접근제어자를 제거하고 싶다면 `-`와 함께 접근 제한자를 적용하면 된다.

제거할 때도 마찬가지로 두 접근제어자를 동시에 적용 가능하다.

### 15.1.3 제네릭 매핑 타입

제네릭 타입 내에서도 `keyof` 연산자를 통해 기존 인터페이스나 객체 타입을 그대로 가져올 수 있다.

동시에 접근제한자도 적용이 가능하다.

일반적으로 사용하는 예시는 기존에 존재하는 인터페이스를 구조분해할 때 사용된다.

구조분해함과 동시에 선택적인 속성을 부여하고 싶다면 제네릭 타입으로 매핑할 때 접근제어자를 사용하면 된다.

`Partial<T>` 내장 유틸리티 타입을 통해 `T`타입의 모든 속성을 선택 사항으로 만들 수도 있다.

이거 이번 Vue 과제 서버리스 함수에서 사용했었음

---

## 15.2 제네릭 조건부 타입

조건부타입은 삼항연산자 처럼 조건에 따라 서로 다른 타입을 지정이 가능하다.

### 15.2.1 제네릭 조건부 타입

여기에 제네릭을 추가하게 되면 이전 타입에 대해서 할당 가능 여부를 체크할 수 있다.

```ts
type 숫자타입인지에따라불리언적용<T> =
  T = extends number ? true : false

type 함수타입인지확인하고함수타입적용 =
  T extends () => any
    ? T
    : () => T
```

### 15.2.2 타입 분산

조건부 타입은 유니언에 분산된다.

```ts
type 타입분산<T> = T extends string ? T : T[];

type A = 타입분산<string | number>;
// 타입 : string | number[]
```

### 15.2.3 유추된 타입

`infer`를 통해 조건부 타입이 `true`인 경우 새로운 타입을 적용 가능하다.

이를 통해 재귀적 조건부 타입을 생성이 가능하다.

```ts
// 모든 차원 배열의 item 타입을 재귀적으로 검색이 가능하다.
type 재귀유추타입<T> = T extends (infer Item)[] ? 재귀유추타입<Item> : T;
```

### 15.2.4 매핑된 조건부 타입

매핑된 타입은 기존 타입의 모든 멤버에 변경 사항을 적용하고  
조건부 타입은 기존 타입 각각에 변경 사항을 적용한다.

```ts
// 타입의 함수가 아닌 각 멤버를 함수로 바꾼다
type 매핑조건부타입<T> =
  [K in keyof T]: T[K] extends (...args: any[]) => any
    ? T[K]
    : () => T[K]
```

---

## 15.3 never

never와 botton 타입은 가능한 값이 없고 접근도 불가능함을 의미한다.

- `&` 교차 타입에 never를 적용하면 never가 된다.
- `|` 유니언 타입에 never는 무시된다.

### 15.3.2 never와 조건부 타입

제네릭 조건부 타입은 일반적으로 유니언에서 필터링을 하기 위해 never를 사용한다.

```ts
type OnlyString<T> = T extends string ? T : never;
```

조건부 타입 false 부분에 never를 사용하면 타입 추출에 용이하다.

### 15.3.3 never와 매핑된 타입

유니언에서 never로 매핑된 타입에서 멤버를 필터링할 때도 사용이 가능하다.

```ts
type OnlyStringProperties<T> = {
  [K in keyof T]: T[K] extends string ? K : never;
}[keyof T];
```

---

## 15.4 템플릿 리터럴 타입

문자열 타입이 패턴에 맞는지 확인하기 위해서 템플릿 리터럴 타입을 사용할 수 있다.

`type 템플릿리터럴타입 = '패턴${string}'` 과 같이 해당 패턴이 포함되었는지 체크한다.

타입 보간법을 사용할 수 있다.

```ts
type 타입1 = '안녕' | '아침';
type 타입2 = 'Vue' | 'React';

type 타입체크보간 = `${타입1}-${타입2}`;

// "안녕-Vue" | "안녕-React" | "아침-Vue" | "아침-React"
```

템플릿 리터럴 타입으로 원시타입 또는 원시 타입 조합이 포함되도록 타입 체크가 가능하다.

### 15.4.1 고유 문자열 조작 타입

내장된 제네릭 유틸리티 문자열 리터럴 타입이 있다.

- Uppercase: 대문자 변환
- Lowercase: 소문자 변환
- Capitalize: 첫 번째 문자 대문자 변환
- Uncapitalize: 첫 번째 문자 소문자 변환

```ts
type 대문자문자열리터럴 = Capitalize<'hello.'>;

// 타입 : "Hello."
```

### 15.4.2 템플릿 리터럴 키

매핑된 타입의 인덱스 시그니처에 문자열처럼 적용이 가능하다.

### 15.4.3 매핑된 타입 키 다시 매핑하기

매핑된 타입의 키를 다시 템플릿 리터럴 타입으로 변환해서 적용이 가능하다.

이때는 `as` 키워드를 통해 적용한다.

`keyof typeof`를 통해 객체 타입에서 매핑된 타입을 만들 수 있다.

하지만 제네릭 타입에서 매핑된 템플릿 리터럴 타입의 키를 다시 사용하려고 하면 symbol 타입으로 사용이 불가능하다.

이를 해결하기 위해서는 `&` 교차 타입을 통해 `string & symbol`이 never가 되는 것을 이용해 무시하게 만들 수도 있다.
