# Ch6. 배열

## 6.1 배열 타입

배열을 초기 선언할 때는 꼭 초깃값이 필요하지 않다. 빈 배열도 가능하기 때문이다.
이럴 경우에도 TS에서는 배열이 포함해야 하는 값의 타입을 지정해주려고 한다면 `타입[]` 형태로 지정이 가능하다.
제네릭을 사용한 `Array<타입>` 형태도 가능하지만 `타입[]`을 권장한다.

### 6.1.1 배열과 함수 타입

괄호를 통해 함수 타입 반환 부분과 배열 타입 묶음을 구분할 수 있다. 헷갈릴 수 있으니 주의해서 묶자

```ts
// string배열을 반환하는 함수 타입
let createStrings: () => string[];

// string을 반환하는 함수 배열 타입
let stringCreators: (() => string)[];
```

### 6.1.2 유니언 타입 배열

배열 각 요소가 여러 선택 타입 중 하나일 경우에는 유니언 타입을 사용해야 한다. 하지만 이 때도 괄호를 사용하면 아예 다른 의미가 되므로 주의하자.

```ts
// string 타입 또는 number의 배열 타입
let stringOrArrayOfNumbers: string | number[];

// string 또는 number 타입 요소를 가지는 배열 타입
let arrayOfStringOrNumbers: (string | number)[];
```

### 6.1.3 any 배열의 진화

배열에 따로 타입을 지정하지 않으면 `any[]`로 취급한다. 따라서 배열 안의 요소 타입을 명시적으로 지정해야 한다.

### 6.1.4 다차원 배열

2차원 배열의 경우 `[][]`로 나타낼 수 있다.
요소가 number 타입일 경우에는 `number[][]` 또는 `(number[])[]`로 나타낼 수 있다.
n차원일 경우에는 n개만큼 `[]`을 뒤에 추가하면 된다.

<br>

---

## 6.2 배열 멤버

배열 안의 요소를 따로 변수로 지정하게 되면 기존에 지정했던 배열의 타입을 그대로 가져간다.
배열의 타입이 유니온일 경우에도 그대로 가져간다.

```ts
const defenders = ['defender1', 'defender2'];
const defender1 = defenders[0]; // string 타입

const soldiersOrDates = ['soldier1', new Date(1996, 6, 9)];
const soldierorDate = soldiersOrDates[0]; // string | Date 타입
```

### 6.2.1 주의 사항: 불안정한 멤버

배열 범위밖을 벗어나는 멤버에도 해당 배열의 타입이 적용된다.
JS에서는 범위를 벗어나기 때문에 에러를 발생시키지만 TS에서는 오류가 발생하지 않기 떄문에 주의하자.

=> 이런 경우에는 확인하는 방법이 `noUncheckedIndexedAccess` 플래그가 있지만 엄청 엄격해서 프로젝트에 적용하기에는 까다로운 플래그이다.

<br>

---

## 6.3 스프레드와 나머지 매개변수

### 6.3.1 스프레드

스프레드 연산자를 통해 배열을 결합할 수 있다. 이 때는 두 배열의 타입이 합쳐진 배열 타입으로 지정된다.

```ts
const soldiers = ['soldier1', 'soldier2']; // string
const ages = [19, 24]; // number
const conjoined = [...soldiers, ...ages]; // (string | number)[]
```

### 6.3.2 나머지 매개변수 스프레드

배열에 나머지 매개변수 스프레드를 통해 인수를 넘겨줄 때 배열 타입으로 선언할 수 있다. 이 경우에는 함수를 호출할 때 해당 나머지 매개변수에도 타입을 일치시켜주어야 한다.

<br>

---

## 6.4 튜플

JS와 다르게 TS는 크기가 정해져 있는 배열인 튜플이 존재한다.
튜플에서는 각 인덱스에 다른 타입을 지정할 수 있어 구체적으로 설정이 가능하다.

```ts
let 나이와이름 = [number, string];

나이와이름1 = [28, 'ikjun']; // Ok
나이와이름2 = ['27', '누구세요']; // Error
```

튜플을 통해 단일 조건에 대해서 두 개의 변수에 초기값을 설정하기 위해 배열 구조 분해 할당과 함께 자주 사용된다.

```ts
// 나이 : number 타입, 이름 : string 타입
let [나이, 이름] = 조건 ? [28, 'ikjun'] : [27, 'ikjun 만 나이'];
```

### 6.4.1 튜플 할당 가능성

가변 길이를 가지는 배열은 튜플 타입에 할당 불가능하다.
일반적으로 배열을 튜플로 선언하지않고 할당만 하면 튜플이 아니라 일반 배열 타입을 가진다.  
이것을 튜플 타입을 가지는 변수에 할당하려고 하면 에러가 발생한다.

### 나머지 매개변수로서의 튜플

나머지 매개변수로 전달할 때는 튜플 타입을 통해 정확하게 요소의 갯수를 맞춰서 지정할 수 있다.
나머지 매개변수의 타입을 그냥 배열로 지정하면 에러가 발생한다.

### 6.4.2 튜플 추론

배열이 변수의 초기값 또는 함수 반환값으로 사용되면 튜플이 아니라 배열 타입으로 추론된다.

따라서 이를 명시적으로 하기 위해서는 **명시적 튜플 타입**과 **const assertion(`as`)**을 사용해야 한다.

### 명시적 튜플 타입

함수의 반환값에 튜플 타입을 명시적으로 선언하면 튜플 추론이 잘못되는 것을 방지할 수 있다.

### const 어서션 `as`

`as const` 연산자를 통해 타입을 읽기전용으로 지정할 수 있다.
이렇게 되면 배열이 아니라 튜플 타입으로 처리된다.  
단순히 튜플 타입이 아니라 리터럴 형식으로 값 수정도 불가능한 유일한 읽기전용 타입으로 지정된다.  
따라서 일반적인 튜플 타입과도 다르다.

```ts
const 유니온타입 = [123, 'a']; // (string | number)[] 타입
const 읽기전용튜플 = [123, 'b'] as const; // readonly [123, "b"] 타입

const 읽기전용튜플2: [number, string] = [123, 'c'] as const;
// 에러

const 읽기전용튜플3 = [123, 'c'] as const;
읽기전용튜플3[0] = 142; // 에러
```
