# Ch10. 제네릭

제네릭을 사용하면 타입 간의 관계를 알아낼 수 있다.
제네릭 타입 매개변수는 전형적으로 T나 U와 같은 단일 문자 이름 또는 Key와 Value 같은 파스칼 케이스 이름으로 지정한다.
`<T>`와 같이 삼각 괄호로 선언한다.

# 10.1 제네릭 함수

매개변수 괄호 바로 앞에 제네릭을 선언한다. 이것을 통해 함수의 반환 타입을 추론가능하다.

```ts
function identity<T>(input: T) {
  return input; // 반환값 input의 타입이 T가 된다.
}

const numeric = identity('me'); // "me" 타입
const stringy = identity(123); // 123 타입
```

```ts
const arrowIdentity = <T>(input: T) => input; // 화살표 함수 제네릭 선언
```

제네릭 화살표 함수 구문은 JSX 구문과 충돌하므로 리액트 프로젝트에 사용 시 제한이 있을 수 있다.

### 10.1.1 명시적 제네릭 호출 타입

제네릭 매개변수만 선언하고 호출할 때 따로 타입을 지정하지 않으면 기본값이 unknown으로 설정된다.
이것을 막기 위해서 호출할 때 명시적 제네릭 타입 인수(`이름<Type>`)를 사용하면 된다.
필수는 아니기에 필요할 경우 사용하면 된다.

### 10.1.2 다중 함수 타입 매개변수

`이름<제네릭1, 제네릭2...>`처럼 제네릭을 여러 개 지정 가능하다.
주의할 점은 여러 개의 제네릭 매개변수를 선언하면 호출할 때 모두 선언하거나 모두 선언하지 않아야 에러가 발생하지 않는다.
또한 세 개 이상의 제네릭은 코드 가독성을 위해 지양하는 것이 좋다.

<br>

---

## 10.2 제네릭 인터페이스

인터페이스에도 제네릭을 사용 가능하다.
내장 Array 메서드는 제네릭 인터페이스로 정의된다.
`Array<T>`를 통해 배열 안 저장되는 데이터의 타입을 나타낸다.

### 10.2.1 유추된 제네릭 인터페이스 타입

타입스크립트는 인수로 전달된 값의 타입에 따라 타입을 추론한다. 이것이 일치하지 않을 경우 에러가 발생한다.
인터페이스가 제네릭 타입 매개변수를 선언할 경우에는 필수적으로 해당 타입 인수를 포함해야 한다.

<br>

---

## 10.3 제네릭 클래스

클래스에서도 멤버에서 사용할 제네릭 타입 매개변수를 각각 선언할 수 있다.
이 때도 마찬가지로 제네릭 타입이 무엇인지 선언이나 호출 시 제공해야 한다.

### 10.3.1 명시적 제네릭 클래스 타입

기본적인 명시적 제네릭 호출 타입처럼 클래스에서도 명시적으로 제네릭 클래스 타입을 지정해주지 않으면 기본값이 unknown이 된다.

### 10.3.2 제네릭 클래스 확장

`extends` 키워드를 통해 제네릭 클래스를 확장할 수도 있다. 이 경우에도 해당 제네릭 타입 인수를 명시적으로 지정해주어야 한다.

### 10.3.3 제네릭 인터페이스 구현

`implements` 키워드를 통해 제네릭 인터페이스를 제네릭 클래스에 적용할 수 있다.

### 10.3.4 메서드 제네릭

클래스 메서드에서는 클래스 인스턴스와 별개로 자체 제네릭 타입을 선언 가능하다.

### 10.3.5 정적 클래스 제네릭

static으로 선언된 정적 멤버는 기본적인 인스턴스 멤버와 구별된다.
따라서 클래스 인스턴스와 별개로 자체 타입 매개변수를 사용할 수 있다. 하지만 클래스에 선언된 타입 매개변수는 사용이 불가능하다.

<br>

---

## 10.4 제네릭 타입 별칭

타입 별칭을 통해 제네릭 타입을 구조화할 수 있다. 각 타입 별칭에는 타입 매개변수를 정의하는 부분이 같이 주어진다.
제네릭 타입 별칭을 보통 제네릭 함수의 타입을 설명하는 함수와 함께 사용된다.

### 10.4.1 제네릭 판별된 유니언

조건에 맞게 판별된 유니언을 제네릭과 함께 사용하면 조건에 맞게 제네릭을 적용해서 알맞은 속성과 타입을 적용할 수 있다. 타입 가드와 함께 사용할 수 있다.

<br>

---

## 10.5 제네릭 제한자

### 10.5.1 제네릭 기본값

`=`를 통해 제네릭이 제공되지 않았을 경우 기본 타입값을 지정할 수 있다.
앞서 선언된 제네릭을 기본 타입값으로 지정도 가능하다. 이 경우에는 해당 제네릭은 무조건 제공되어야 추론이 가능하므로 에러가 발생하지 않는다.
기본 타입 매개변수는 선언 시 가장 마지막에 배치되어야 한다. 기본값이 없는 제네릭 타입이 기본값이 있는 제네릭 타입 앞에 오게 되면 에러가 발생한다.

```ts
function 기본값이맨뒤<첫번째, 두번째, 세번째 = number>() {}
function 기본값이맨뒤가아님<첫번째, 두번째 = number, 세번째>() {} // 에러 발생
```

<br>

---

## 10.6 제한된 제네릭 타입

제네릭의 타입을 제한하기 위해서는 `<제네릭 extends 제한할타입(인터페이스)>` 형태로 제한할 타입을 지정할 수 있다.

### 10.6.1 keyof와 제한된 타입 매개변수

`keyof` 키워드와 `extends` 키워드를 함께 사용해서 이전 타입 매개변수의 키로 제한하여 타입 매개변수를 지정할 수 있다.
이것을 통해 타입 매개변수가 객체 형태로 주어졌을 경우 해당 키의 타입을 구체적으로 명시할 수 있다.

<br>

---

## 10.7 Promise

Promise는 최종적으로 resolve된 값을 나타내는 단일 타입 매개변수를 가진 Promise 클래스로 표현할 수 있다.

### 10.7.1 Promise 생성

Promise의 타입 인수를 명시적으로 선언해주어야 한다. 마찬가지로 선언하지 않으면 unknown로 가정되므로 주의하자.

`.then` 메서드로 반환되는 resolve된 값으로 새로운 타입 매개변수가 지정된다. 업데이트가 된다고 생각하면 된다.

### 10.7.2 async 함수

async 함수 내에 있는 await가 반환하는 Promise의 resolve 값의 타입 매개변수가 async의 타입으로 반환된다.
따로 Promise가 반환되지 않으면 직접 반환하는 값이 Promise로 매핑된다.

<br>

---

## 10.8 제네릭 올바르게 사용하기

제네릭은 필요할 때만 사용하는 것이 코드 가독성에 도움이 된다.

### 10.8.1 제네릭 황금률

타입 매개변수가 최소 두 번 이상 사용되었다면 제네릭을 사용하는 것이 좋다. 그것이 아니라 한 번만 사용되는 타입 매개변수는 그냥 바로 타입을 지정하는 것이 좋다.

### 10.8.2 제네릭 명명 규칙

제네릭은 첫 번째 타입 인수로 `T`, 그 다음으로는 `U`, `V` 등을 지정하는 표준 명명 규칙이 있다.
또는 해당 용어의 첫 글자를 대문자로 사용한다.
예를 들어 상태 관리는 `S`, 데이터 구조의 키와 값은 `K`, `V`로 정하는 것이다.
하지만 단일 문자가 특별한 의미가 없다면 오히려 코드를 이해하는데 힘들 수도 있다.
따라서 정확한 용도를 가르키지 않는다면 파스칼 형식으로 명시하는 수밖에 없다.
