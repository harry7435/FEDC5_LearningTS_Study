# Ch4. 객체

원시 타입이 아닌 복잡한 객체 타입을 다뤄보자.

## 4.1 객체 타입

`{...}` 구문을 통해 객체 타입을 지정할 수 있다.  
객체 값의 속성에 접근하려면 `객체명.속성명` 또는 `객체명['속성명']`으로 가능하다.

### 4.1.1 객체 타입 선언

객체 타입을 선언하면 이후 객체 형태로만 사용 가능하다. 다른 원시 타입으로는 사용 불가능하다.

### 4.1.2 별칭 객체 타입

`type 객체타입명 = { ... }`으로 코드 스니펫을 지정해서 별칭으로 사용 가능하다.  
이후 배울 `인터페이스`를 사용하는 것을 권장한다.

## 4.2 구조적 타이핑

> 타입 시스템은 **구조적으로 타입화** 되어 있다.

객체 타입으로 선언되었을 경우에는 해당 객체 내의 속성을 가질 수 있다.

이러한 구조적 타입화 덕분에 타입스크립트는 런타임 이전에 타입에 대한 검증이 가능하다.

### 4.21 사용 검사

객체 타입으로 애너테이션하게 되면 해당 객체 타입에 할당할 수 있는지 검사한다.  
속성으로 지정한 타입이 하나라도 없으면 에러가 발생한다.  
또한 속성이 있더라도 타입이 일치하지 않아도 에러가 발생한다.

> 객체 타입의 값 내 속성과 속성의 타입이 모두 일치하는지를 검사하기 때문에 타입스크립트는 강력하다.

### 4.2.2 초과 속성 검사

객체 타입을 선언한 속성 갯수보다 많은 속성이 있다면 에러가 발생한다.  
초과 속성 검사는 배열, 클래스, 함수 등에서 모두 적용된다.

### 4.2.3 중첩된 객체 타입

중첩된 객체로도 타입을 지정할 수 있다.  
이 때에도 객체 구조가 정확하게 일치해야 에러가 발생하지 않는다.  
객체 타입을 중첩할 때 중첩하는 객체를 타입 별칭으로 지정하면 코드 가독성이 증가한다.

### 4.2.4 선택적 속성

`?`을 애너테이션할 때 속성명 뒤에 붙이면 선택적 속성으로 지정된다.  
이 속성은 꼭 포함되지 않아도 무방하다. 단, `undefined`를 포함한 유니언 타입 속성에서는 값이 `undefined`일지라도 존재해야 한다.

## 4.3 객체 타입 유니언

### 4.3.1 유추된 객체 타입 유니언

변수에 여러 객체 타입이 가능한 초기값이 주어지면 객체 타입 유니언으로 유추한다. 따라서 가능한 각 객체 타입을 구성하는 모든 요소가 가능하다.

### 4.3.2 명시된 객체 타입 유니언

직접 객체 타입 유니언을 명시하게 되면 객체 타입을 더 명확하게 할 수 있다. 공통적으로 포함되는 속성을 구분하기가 편하다.

### 4.3.3 객체 타입 내로잉

`in` 키워드를 통해 객체 안에 속성이 있는지를 확인하여 타입 가드를 통해 객체 타입 내로잉이 가능하다.

### 4.3.4 판별된 유니언

객체의 속성이 객체의 타입을 나타내도록 할 수도 있다. 이렇게 정의된 타입을 `판별된 유니언`, 해당 속성을 `판별값`이라고 부른다.

## 4.4 교차 타입

유니언 타입과 비슷하게 `&` 연산자를 통해 여러 타입을 결합해 교차 타입을 지정할 수 있다.

### 4.4.1 교차 타입의 위험성

### 긴 할당 가능성 오류

지나치게 복잡하게 교차 타입을 만들면 할당 가능성을 판별하기가 어려워진다.

### never

원시 타입은 동시에 여러 타입이 될 수 없기에 원시 타입을 교차 타입으로 지정하면 `never`` 타입이 된다.
