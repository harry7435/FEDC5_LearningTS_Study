타입스크립트가 해당 값을 바탕으로 추론을 수행하는 두 가지 핵심 개념 : 유니언, 내로잉

# 3.1 유니언 타입

`타입 | 타입 | ...`

```tsx
let uni: string | number | number[];
```

이후 메소드를 사용하려고 할때에도 유니언으로 선언한 모든 타입에 모두 가능해야 사용 가능하다.

ex) 위에서의 uni에 uni.toUpperCase() 불가능! 왜? 숫자나 숫자배열일 수도 있으니까!

<br/>

# 3.2 내로잉

값이 정의, 선언 혹은 이전에 유추된 것보다 더 구체적인 타입임을 코드에서 유추하는 것

이에 사용할 수 있는 논리적 검사 === 타입 가드

## 3.2.1 값 할당을 통한 내로잉

유니언 타입이 명시되고 특정 타입으로 초기화되면 내로잉이 작동됨. 하지만 이후에 유니언 타입에 명시된 다른 타입으로 할당이 가능하긴 함!

## 3.2.2 조건 검사를 통한 내로잉

```tsx
let scientist = Math.random() > 0.5 ? "Fanklin" : 40; // number | string

if (scientist === "Franklin") {
  // 여기선 scientist: string 으로 명시됨
  scientist.toUpperCase(); // 그래서 가능!
}
scientist.toUpperCase(); // 여기선 불가능!!
```

## 3.2.3 typeof 검사를 통한 내로잉

```tsx
let scientist = Math.random() > 0.5 ? "Fanklin" : 40; // number | string

if (typeof scientist === "string") {
  // 내로잉(즉, 타입가드)되었기 때문에 string타입으로 제한됨
  scientist.toUpperCase(); //  가능!
}
scientist.toUpperCase(); // 여기선 불가능!!
```

<br/>

# 3.3 리터럴 타입

원시 타입 값 중 어떤 것이 아닌 특정 원싯값으로 알려진 타입

```tsx
const name = "hero";
```

라면, name의 타입은 string타입이 되면서도 리터럴타입으로는 ‘hero’ 이다.

이렇게 문자열, 숫자, true,false 등 할당된 리터럴 그 값! 이 된다.

유니언타입에서 다른 원시 타입과 섞어 사용 가능

## 3.3.1 리터럴 할당 가능성

리터럴 타입으로 선언된 변수에는 해당 리터럴 값만 할당할 수 있습니다.

```tsx
const name = "hero";

name = "devil"; // ERROR !!! 왜? 리터럴타입으로 'hero'가 지정되있으니까
```

하지만, 리터럴 타입을 그 값이 해당하는 원시타입에 할당하는 것은 가능!!

```tsx
const nickname = ""; // string 타입!

nickname = "foo"; // OK

name = nickname; // ERROR!!! 위와 같이 name은 리터럴 타입이다
```

<br/>

# 3.4 엄격한 null 검사

## 3.4.3 초깃값이 없는 변수

값이 할당되기 전까진 변수가 undefined이다. 유니언으로 undefined도 포함이 되어있다면 할당 전 접근해도 오류가 발생하지 않는다.

<br/>

# 3.5 타입 별칭

```tsx
type 타입명 = 타입;

type MyType = boolean | string | undefined;

let key: MyType;
```

타입 별칭은 타입 시스템에만 존재한다. “개발 시”에만 존재하고 런타임에는 존재하지 않기 때문에 참조X

다른 타입 별칭에 참조도 가능하다

```tsx
type MyType2 = MyType | number;
```

++추가적으로

```tsx
let key2 : MyType | number;
이렇게 변수에서도 가능!
```
