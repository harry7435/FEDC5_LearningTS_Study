# 4.1 객체 타입

## 4.1.1 객체 타입 선언

```tsx
const obj: {
  a: number;
} = {
  a: 0,
};
```

## 4.1.2 별칭 객체 타입

```tsx
type ObjType = {
	name : string;
	age : number;
}

const obj2 : ObjType = {
	name : 'hero';
	age : 9;
}
```

# 4.2 구조적 타이핑

타입을 충족하는 모든 값을 해당 타입의 값으로 사용.

객체 타입이면, 해당 값에 그 모든 속성이 있어야 함.

```tsx
type MyType = {
  name: string;
};

const user = {
  name: "hero",
  age: 0,
};

let test: MyType = user; // age속성 없는데 가능!! [4.2.2]참고
```

## 4.2.1 사용 검사

할당하는 값에는 개체 타입의 필수 속성이 **모두 있어야 한다**. 그리고 해당 속성의 타입까지 맞아야한다.

```tsx
type User = {
  name: string;
  age: number;
};

const user1: User = {
  name: "n1",
  age: 1,
}; // OK

const user2: User = {
  name: "n2",
}; // ERROR !! Property 'age' is missing in type {name : string}
```

## 4.2.2 초과 속성 검사

```tsx
type User = {
  name: string;
  age: number;
};

const user1: User = {
  name: "n1",
  age: 1,
}; // OK

const user2: User = {
  name: "n2",
  age: 2,
  zip: "123123", // Type '{ name: string; age: number; zip: string; }' is not assignable to type 'User'.
  //Object literal may only specify known properties, and 'zip' does not exist in type 'User'.
};
```

초과 속성 검사는 **객체 타입으로 선언된 위치에서 생성되는 객체 리터럴에 대해서만 일어납니다**!!!!

[4.1]에서 처럼 이미 선언된 객체 리터럴을 제공하면 초과 속성 검사를 우회할 수 있다.

## 4.2.3 중첩된 객체 타입

객체는 또 다른 객체의 멤버가 될 수 있으므로 객체 타입도 중첩이 가능하다. 당연히 하위 객체에서의 속성과 타입까지 일치해야한다.

일부를 type을 사용하여 별칭 객체 타입으로 추출할 수 있다. → 가독성에 좋음

## 4.2.4 선택적 속성

`?`

```tsx
type Book = {
  author?: string;
  pages: number;
};
```

선택적 속성과 undefined를 포함한 유니언 타입의 속성은 다르다!

?를 사용한 선택적 속성은 해당 속성이 존재하지 않아도 되지만, undefiend에선 반드시 존재해야 한다. 값이 undefined여도 된다는 것일 뿐.

<br/>

# 4.3 객체 타입 유니언

## 4.3.1 유추된 객체 타입 유니언

변수에 여러 객체 타입 중 하나가 될 수 있는 초기값이 주어지면 객체타입유니언으로 타입을 유추함!

이때 각 객체 타입을 구성하고 잇는 모든 요소를 가지게 된다. 한쪽에 있을수도 있고 없을 수도 있는 속성은 선택적속성?: 이지만 구성요소로 주어짐

```tsx
const poem =
  Math.random() > 0.5
    ? { name: "the", pages: 7 }
    : { name: "her", rhymes: true };

/*
const poem: {
    name: string;
    pages: number;
    rhymes?: boolean;
} | {
    name: string;
    rhymes: boolean;
    pages?: undefined;
}
*/
```

> ### 질문
>
> ```
> const poem: {
>    name: string;
>    pages: number;
>    rhymes?: boolean; // 왜 이렇게 number로가 아닌거지 ?  ?
> } | {
>    name: string;
>    rhymes: boolean;
> 		pages? : number; /// ? ? ?
> }
>
> poem.names; // string
> poem.pages; // number | undefined
> poem.rymes; // boolean | undefined
> ```

## 4.3.2 명시된 객체 타입 유니언

객체 타입을 더 명확히 정의하기 위해서 객체 타입의 조합을 명시하자

-> 선택적 속성으로 구성요소가 주어지지 않음!

```tsx
type PoemWithPages = {
  name: string;
  pages: number;
};

type PoemWithRymes = {
  name: string;
  rhymes: number;
};
const poem = PoemWithPages || PeomWithRymes;

const poem =
  Math.random() > 0.5 ? { name: "the", pages: 7 } : { name: "her", rhymes: 10 };

poem.names; //OK
poem.pages; // ERROR !!
poem.rymes; // ERROR !!
```

## 4.3.3 객체 타입 내로잉

객체에서 타입가드를 할 땐

```tsx
if ( 'pages' in poem){
이렇게 in을 활용하자!

if (peom.pages) 는 불가능!!!!! 애초에 존재하지 않는 속성이면 접근이 안되니까!
```

## 4.3.4 판별된 유니언

객체의 속성에 객체의 형태를 나타내도록한다. 이런 형태가 “판별된 유니언”이고, 객체타입을 가리키는 속성이 “판별값”

```tsx
{name : 'the', pages: 4, **type : 'pages'** }
```

# 4.4 교차 타입

`&` intersection type

2개 이상의 타입이 병합된 타입

`타입 & 타입 & ...`

```tsx
type UserA = {
  name: string;
  age: number;
};
type UserB = {
  isValid: boolean;
};

const userA = (UserA = {
  name: "a",
  age: 12,
}); // 지정된 속성 외 사용 불가능 !!!!

const userC: UserA & UserB = {
  name: "c",
  age: 40,
  isValid: true,
};
```

유니언 타입과도 결합 가능!

## 4.4.1 교차 타입의 위험성

긴 할당의 오류

타입 할당 오류메세지 이해에도 어려움이 생긴다.
