타입스크립트는 재네릭을 사용해 타입 간의 관계를 알아냅니다.

<br/>

# 10.1 제네릭 함수

```tsx
function func<T>(input: T) {
  return input;
}

const func2 = <T,>(input: T) => input;
```

## 10.1.1 명시적 제네릭 호출 타입

매개변수 타입을 모르는 경우 기본값 unknown이 설정되는 것을 피하기 위해 해당 타입 인수가 무엇인지 명시적으로 알려주는 **명시적 제네릭 타입 인수**를 사용해 함수를 호출할 수 있다.

<br/>

# 10.2 제네릭 인터페이스

```tsx
interface Intf<T> {
  inside: T;
}
```

## 10.2.1 유추된 제네릭 인터페이스 타입

…

<br/>

# 10.3 제네릭 클래스

## 10.3.2 제네릭 클래스 확장

확장시 기본 클래스에 대한 타입 인수를 유추하지 않는다. 기본 값이 없는 모든 타입 인수는 명시적 타입 애너테이션을 사용해 지정해야한다.

<br/>

# 10.4 제네릭 타입 별칭

## 10.4.1 제네릭 판별된 유니언

( 판별된 유니언: type 속성을 두면서 타입을 값으로 두는거, 내로잉)

<br/>

# 10.5 제네릭 제한자

## 10.5.1 제네릭 기본값

> 제네릭 타입이 타입 애너테이션에 사용되거나 extends 또는 implements의 기본 클래스로 사용되는 경우, 각 타입 매개변수에 대한 타입 인수를 제공해야 한다. 또, 기본값을 주어 타입인 수를 제공할 수 있다.

```tsx
interface Quote<T = string> {
  value: T;
}

let exp: Quote<number> = { value: 123 }; // 가능

let mismatch: Qutoe = { value: 123 }; // ERROR!! 명시안했으면 기본값인 string이니까
```

```tsx
interface KeyValuePair<Key, Value = Key> {
  key: Key;
  value: Value;
}

let allExp: KeyValuePair<string, number> = {
  //let allExp: KeyValuePair<string, number>
  // 생략
};

let oneDefaulting: KeyValuePair<string> = {
  //let oneDefaulting: KeyValuePair<string, string>
  // Value = Key 이니까
  //
};

let fistMissing: KeyValuePair = {
  // ERROR!! Generic type 'KeyValuePair<Key, Value>' requires between 1 and 2 type arguments.(2707)
  //
};
```

기본 타입 매개변수도 기본 함수 매개변수처럼 선언 목록 젱리 마지막!

<br/>

# 10.6 제한된 제네릭 타입

```tsx
interface WithLength {
  length: number;
}
function logWithLength<T extends WithLength>(input: T) {
  console.log(`length : ${input.length}`);
  return input;
}

logWithLength("HHHIHHI"); // function logWithLength<"HHHIHHI">(input: "HHHIHHI"): "HHHIHHI"
// [LOG]: "length : 7"
// 그럼 여기서 <T extends WithLength> 가 뭘까요 ...
// interface extendedWithLength {
//     length : number
// }
// 그냥 요렇게 인가..? WithLength타입을 쓸건데 이걸 제네릭타입화 시키는건가?
// 근데 타입엔 왜 logWithLength<"HHHIHHI"> 이건 뭐지

logWithLength([false, true]); // function logWithLength<boolean[]>(input: boolean[]): boolean[]
// [LOG]: "length : 2"
```

## 10.6.1 keyof와 제한된 타입 매개변수

```tsx
function get<T, Key extends keyof T>(container: T, key: Key) {
  return container[key];
}
const roles = {
  a: "A",
  b: "B",
};

const fav = get(roles, "a"); // 여기서 get은
// function get<{
//     a: string;
//     b: string;
// }, "a">(container: {
//     a: string;
//     b: string;
// }, key: "a"): string

const cc = get(roles, "c"); // ERROR Argument of type '"c"' is not assignable to parameter of type '"a" | "b"'.
// 여기서 get은
// function get<{
//     a: string;
//     b: string;
// }, "a" | "b">(container: {
//     a: string;
//     b: string;
// }, key: "a" | "b"): string

// 일단 먼저 container로 roles가 들어가니까 roles의 타입인 { a:string, b:string} 이 T가 된다.
// keyof T는 T의 키값을 유니온타입으로 만들어주기 때문에  'a'| 'b' 가된다. 그게 Key가 된다.
// 두번째 인자 key는 그 Key 타입을 만족해야하기때문에 리터럴타입인 'a'나 'b'를 만족해야 한다는 뜻...
```

<br/>

# 10.7 Promise

> Promise는 타입스크립트 타입 시스템에서 최종적으로 resolve된 값을 나타내는 단일 타입 매개변수를 가진 Promise 클래스로 표현됨

## 10.7.1 Promise 생성

> 값을 resolve하려는 Promise를 만드려면 Promise의 타입 인수를 명시적으로 선언해야한다.

```tsx
const resolveString = new Promise<string>((resolve) => {
  // Promise<string>
  setTimeout(() => resolve("DONE"), 1000);
});
```

## 10.7.2 async 함수

> Promise를 명시적으로 언급하지 않더라도 async 함수에서 수동으로 선언된 반환 타입은 항상 Promise 타입이 됩니다.

```tsx
async function givesPromiseForStr(): Promise<string> {
  return "DONE";
}

async function givesString(): string {
  // ERROR The return type of an async function or method must be the global Promise<T> type
  return "done";
}
```

<br/>

# 10.8 제네릭 올바르게 사용하기

혼동을 일으킬 정도로 제네릭을 많이 사용하지 말자

## 10.8.1 제네릭 황금률

- 적어두 두번 이상 사용되었는지!
  각 함수 타입 매개변수는 매개변수에 사용되어야 하고, 그다음 적어도 하나의 다른 매개변수 또는 함수의 반환 타입에서도 사용되어야 한다.

## 10.8.2 제네릭 명명 규칙

T, U , V

용도를 가리키는 설명적 제네릭 타입 이름 사용이 가장 좋다..
