# 8.1 클래스 메서드

메서드를 호출하려면 허용 가능한 수의 인수가 필요하고, 반환 타입은 유추 가능(재귀 함수의 경우 예외)

<br/>

# 8.2 클래스 속성

클래스의 속성을 읽거나 쓰려면 클래스에 명시적으로 선언해야 합니다.
타입 애너테이션은 선택적으로 붙습니다.

클래스에서 인스턴스에 할당하고 접근하려면, **속성**으로 선언해야한다!!

```tsx
class F {
  d: string;
  // n : string
  constructor(d: string, n: string) {
    // 인자의 문제가 아님. this로 F클래스의 인스턴스에 접근하는거니까 속성에 선언이 필요
    this.d = d;
    console.log(d);

    this.n = d; // ERROR : Property 'n' does not exist on type 'F'.
  }
}

const f = new F("hi", "tmp_n");
f.d; //OK
f.n; // ERROR : Property 'n' does not exist on type 'F'
```

## 8.2.1 함수 속성

**_자바스크립트_**에서 **클래스의 멤버를 호출 가능한 함수로 선언**하는 두가지 구문

- 멤버명() 형식의 메서드 방식
  메서드 접근 방식은 해당 함수를 클래스 프로토타입에 할당한다!! 따라서, 모든 클래스 인스턴스에 동일한 함수 정의!!!!
  ```jsx
  class ClassA {
    funcMethod() {
      console.log("!");
    }
  }
  const test1 = new ClassA();
  const test2 = new ClassA();
  console.log(test1.funcMethod === test2.funcMethod); // true
  ```
- 값이 함수인 속성을 선언
  인스턴스 당 새로운 함수 생성!!!
  화살표 함수내에서 **this**를 통해 **클래스 인스턴스**를 가리킨다.
  ```tsx
  class ClassB {
    funcProp: () => void = () => {
      console.log(this);
    }; //[LOG] ClassB: {}
    // 각 클래스 인스턴스에 대해 다시 생성되는 함수타입임
  }
  const test1 = new ClassB();
  const test2 = new ClassB();
  console.log(test1.funcProp === test2.funcProp); // false
  ```

## 8.2.2 초기화 검사

“엄격한” 초기화 검사에서 클래스 속성에 값이 할당되지 않은 실수 예방 가능

```tsx
class WithValue {
  init = 0;
  later: number; // constructor생성자에서 할당하기 때문에 OK!
  mayBeUndefined: number | undefined;
  unused: number; // ERROR!!! Property 'unused' has no initializer and is not definitely assigned in the constructor.
  constructor() {
    this.later = 0;
  }
}
```

엄격한 strict 모드를 수행하지 않으면 컴파일은 되지만, 결국 런타임 시 문제가 발생하니까 주의.

### 속성에 의도적으로 할당하지 않을 땐?

이름 뒤에 `!` 를 붙여 검사를 비활성화 한다.

이렇게 하면 타입스크립트에 해당 속성이 처음 사용되기 전에 undefined로 할당된다.

```tsx
class AQ {
  pending**!** : string[]; // ! 없으면 위의 예제 처럼 할당되지 않았다는 이슈 발생함
  initialize(pending : string[]){
    this.pending = pending // 이게 '할당'하는 코드
  }
  next(){
    return this.pending.pop()
  }
}
const activities = new AQ()
// activities.initialize(['eat', 'sleep', 'learn']) // 할당하지 않았다면
console.log(activities.pending)  // 이렇게 [LOG]: undefined
```

## 8.2.3 선택적 속성

`?`

`| undefined` 를 포함하는 유니언 타입과 거의 동일하게 작동

엄격한 속성 초기화 검사와 관계없이 클래스 생성자에서 할당하지 않아도 된다!

## 8.2.4 읽기 전용 속성

`readonly`

선언된 위치 또는 생성자에서 초깃값만 할당할 수 있다. 이 후 쓰기 불가능.

원시 타입의 초깃값을 갖는 readonly로 선언된 속성은, 값의 타입이 가능한 한 좁혀진 리터럴 타입으로 유추됩니다!

```tsx
class C {
  readonly read = 'this is' // (property) C.read: "this is"
  read2 = "this is not" // (property) C.read2: string
	...
```

<br/>

# 8.3 타입으로서의 클래스

타입 시스템에서의 클래스는 클래스 선언이 런타임값(클래스 자체)과 타입 애너테이션에서 사용할 수 있는 타입을 모두 생성한다.

```tsx
class Teacher {
  sayHello() {
    console.log("hello");
  }
}
let teacher: Teacher = new Teacher(); // ok

// let teacher: Teacher
teacher = {
  // Teacher클래스 인스턴스처럼 타입이 ()=>void인 sayHello 속성을 가진 모든 객체 할당 가능 // 자주 사용 방식은 아님
  sayHello() {
    console.log("bye");
  },
}; // OK !

teacher = "teacher!!"; // Type 'string' is not assignable to type 'Teacher'.(2322)
```

<br/>

# 8.4 클래스와 인터페이스

`클래스명 implements 인터페이스명` 으로 클래스의 해당 인스턴스가 인터페이스를 준수함을 선언

이로써 클래스가 인터페이스에 할당할 수 있어야함을 타입스크립트에 나타냄

```tsx
interface Learner {
  name: string;
  study(hours: number): void;
}

class Student implements Learner {
  // 내부에 Learner 타입을 만족하는 속성을 다 선언하지 않으면 에러가 난다
  // Class 'Student' incorrectly implements interface 'Learner'.
  // Type 'Student' is missing the following properties from type 'Learner': name, study
}
```

다만, 인터페이스에서 클래스의 메서드 또는 속성 타입을 유추하진 않는다.

```tsx
interface Learner {
  name: string;
  study(hours: number): void;
}

class Student implements Learner {
  name; // Member 'name' implicitly has an 'any' type.(7008)
}
```

이렇게 클래스의 멤버에 타입 애너테이션을 제공하지 않으면 암시적 any 타입오류가 발생한다.

## 8.4.1 다중 인터페이스 구현

쉽표로 구분하여 여러개의 인터페이스를 사용하여 클래스를 선언할 수 있다.

```tsx
class Card implements It1, It2 {
	..
```

각각의 인터페이스의 속성을 모두 가져와야한다!

주의할 것은,

서로 다른 인터페이스에서 같은 이름의 속성을 사용하는데 선언된 타입인 경우, 어느 한쪽만 만족시킬 수 밖에 없고 다른 쪽에 대해 에러를 발생시킨다.

두 인터페이스가 매우 다른 객체 형태를 표현하는 경우엔 동일한 클래스로 구현하지 말자.
<br/>

# 8.5 클래스 확장

타입스크립트는 다른 클래스를 확장하거나 하위 클래스를 만드는 자바스크립트 개념에 타입 검사를 추가한다.

```tsx
class Teacher {
  teach() {}
}
class StudentTeacher extends Teacher {
  learn() {}
}
const teacher = new StudentTeacher();

teacher.teach(); // OK
teacher.learn(); // OK
```

<!-- ## 8.5.1 할당 가능성 확장 -->

## 8.5.2 재정의된 생성자

JS에서와 마찬가지로, 하위 클래스가 자체 생성자(constructor)를 생성하려면 super 키워드를 통해 기본 클래스 생성자 호출을 **먼저** 해야합니다. 또한, this에 접근하는 것보다도 **먼저** 해야 합니다!

## 8.5.3 재정의된 메서드

하위 클래스의 메서드가 기본 클래스의 메서드에 할당될 수 있는 한, 하위 클래스는 기본 클래스와 동일한 이름으로 새 메서드를 다시 선언할 수 있다.

```tsx
class Grade {
  count(grades: string[], letter: string) {
    return grades.length;
  }
}

class Success extends Grade {
  count(grades: string[]) {
    return super.count(grades, "a"); // super : class Grade
  }
}
class Success2 extends Grade {
  count() {
    // 이렇게 타입을 명시 안해도 된다.
    return super.count(["a", "b", "c"], "A"); // super : class Grade
  }
}

class Fail extends Grade {
  count(grades: string[]) {
    return true;
  }
}
const f: Grade = new Fail();
// Type 'Fail' is not assignable to type 'Grade'.
//   The types returned by 'count(...)' are incompatible between these types.
//     Type 'boolean' is not assignable to type 'number'.
```

## 8.5.4 재정의된 속성

하위 클래스는 새 타입을 기본 클래스의 타입에 할당될 수 있는 한, 동일한 이름으로 기본 클래스의 속성을 명시적으로 다시 선언할 수 있습니다. 재정의된 메서드에서 처럼 기본 클래스와 구조적으로 일치해야함.

기본클래스에서 유니온타입인 속성에 대해 하위 클래스에서 그 중 하나를 특정할 순 있지만, 반대로 특정 속성인 기본클래스 속성을 하위클래스에서 유니온타입 집합으로 확장할 순 없다!
<br/>

# 8.6 추상 클래스

“추상 클래스는 하위 클래스들의 공통점들을 모아 추상화하여 만든 클래스”

때로는 일부 메서드의 구현을 선언하지 않고, 대신 하위 클래스가 해당 메서드를 제공할 것을 예상하고 기본 클래스를 만드는 방법이 유용할 수 있다.

클래스명과 해당 메서드에 `abstract` 키워드를 추가한다!

```tsx
**abstract** class Parent{
  **abstract** getName() : string;
}
class Child extends Parent{
  getName(){
    return 'name!'
  }
}
```

해당 메서드를 하위 클래스에서 정의하지 않으면 오류가 발생한다!

또한, 인스턴스화 할 수 없다! 일부 메서드에 대해 정의가 없으니까! (new 생성 못한다는거)

<br/>

# 8.7 멤버 접근성

- public (디폴트)
  모든 곳에서 누구나 접근 가능
- protected
  클래스 내부 또는 하위클래스에서만
- private

  클래스 내부에서만

- static
  정적 함수에서 정적 변수의 값을 변경하는 것은 가능하지만, 정적 함수에서 일반 변수(static 키워드가 없는 변수)의 값을 변경하는 것은 [불가능합니다](https://developer-talk.tistory.com/367).
- readonly

**제한자 선언 순서 : 접근성키워드 > static > readonly**
