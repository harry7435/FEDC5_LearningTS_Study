_연관된 이름으로 객체 형태를 설명하는 또 다른 방법_

<br/>

# 7.1 타입 별칭 VS 인터페이스

타입 별칭

```tsx
type User = {
  name: string;
  age: number;
};
```

인터페이스

```tsx
interface User {
  name: string;
  age: number;
}
```

속성 증가를 위해 병합 가능

이름 있는 객체로 간주 → 디버깅 용이

<br/>

# 7.2 속성 타입

## 7.2.1 선택적 속성

`?`

## 7.2.2 읽기 전용 속성

`readonly` : 속성 앞에 해당 키워드를 추가하면 재할당이 불가능해진다.

인터페이스에서만 사용 가능!!! 실제 객체에선 X

또한, 단지 타입 시스템 구성 요소이다. 개발 중의 수정을 막는 역할!

## 7.2.3 함수와 메서드

인터페이스 멤버를 함수로 선언하는 두가지 방법

```tsx
interface Intf {
  memberFunc1(): void; // 메서드 구문 - 객체의 멤버로 호출되는 함수로
  memberFunc2: () => void; // 속성 구문 - 독립 함수와 동일하게
}
```

js에서 객체를 함수로 선언하는 방법과 동일ㅇㅇ

두 방법 모두 선택적 속성 키워드 `?` 사용 가능

_++ 메서드와 속성의 주요 차이점_

- 속성만 readonly 선언 가능
- 인터페이스 병합에 있어서 두 방식이 다름
- 타입에서 수행되는 일부 작업에 있어서 두 방식이 다름
- 기본 함수가 this를 참조할 수 있다는 것을 알고 있다면 메서드 함수 사용하세요. ↔ 반대의 경우엔 속성 함수를 사용하세요

## 7.2.4 호출 시그니처

> 인터페이스와 객체 타입은 호출 시그니처로 선언할 수 있습니다.
>
> 호출 시그니처는 값을 함수처럼 호출하는 방식에 대한 타입 시스템의 설명입니다.

_인터페이스(타입 별칭)로 함수 타입을 선언해두고 값에 타입으로 지정하는 형태_

```tsx
type TFuncAlias = (input: string) => number; // 타입별칭
const typeFunc : TFuncAlias = (input) => input.length

interface IFuncAlias = (input: string) => number; // 인터페이스
const interfaceFunc : IFuncAlias = (input) => input.length
```

<!-- -->

## 7.2.5 인덱스 시그니처

++ object(객체)는 키:밸류로 이루어진 컨테이터 타입 변수

인덱스 시그니처 구문을 제공해 인터페이스의 객체가 임이의 키를 받고, 해당 키 아래의 특정 타입을 반환할 수 있음을 나타낸다. 자바스크립트 객체 속성 조회는 암묵적으로 키를 문자열로 변환한다!

```tsx
interface WordCounts {
  [i: string]: number; //
}
```

그런데 문제점, 정의되지 않은 키에 대해서도 타입시스템에서 에러가 나지 않는다. 단, 런타임에선 undefined!

이렇게 키:밸류 쌍에서 키를 미리 다 알 수 없다면 Map을 사용하는 편이 안전하다.

Map 구조의 메소드인 .get은 존재하지 않는 키에 대해 요청하면 | undefined를 반환한다. ((9장

### 속성과 인덱스 시그니처 혼합

명시적으로 명명된 속성과 string 인덱스 시그니처를 한번에 포함할 수 있다!

단,인덱스 시그니처에 할당되는 키밸류 외에 존재하는 속성에 대해 값이 존재해야한다!!

```tsx
interface User {
  [key: string]: string | number; //인덱스시그니처. name,age 가 아닌 속성도 들어올 수 있는데 여기에 만족하는 타입을 만족해야함
  name: string;
  age: number;
}
const user: User = {
  name: "Hero",
  //   age: 100, // ERROR : Property 'age' is missing in type '{ name: string; email: string; zip: number; }' but required in type 'User'.
  email: "adf@gmail.com",
  zip: 123,
};
```

혼합해서 사용할때, 인덱스 시그니처의 속성보다 명명된 속성에 대해 더 구체적인 속성 타입 리터럴을 사용하는 방법이 일반적으로 쓰인다.

### 숫자 인덱스 시그니처

<!-- …? -->

## 7.2.6 중첩 인터페이스

객체 타입처럼 인터페이스 타입도 자체 인터페이스 타입 혹은 객체 타입을 속성으로 중첩으로 가질 수 있다.

<br/>

# 7.3 인터페이스 확장

```tsx
interface 인터페이스명 extends 확장할다른인터페이스명 {}
```

이때 파생 인터페이스는 기본 인터페이스의 모든 멤버를 가져야한다.

- 병합

동일 인터페이스 중복 선언시 병합! 덮어씌우지는게 아니다!

- 확장

extends를 이용하여 기존 인터페이스의 속성에 대해 타입을 재정의할수 있다! 단, 기본 인터페이스의 해당 속성을 유니언 타입의 더 구체적인 하위집합으로 만들거나 확장된 타입으로만 가능

```tsx
interface User {
  name: string;
  age: number;
}

interface User2 extends User {
  name: number; // 불가능!!
  //	Interface 'User2' incorrectly extends interface 'User'.
  //   Types of property 'name' are incompatible.
  //    Type 'number' is not assignable to type 'string'.
}
```

```tsx
interface User {
  name: string | number; // 여기서
  age: number;
}

interface User2 extends User {
  name: string; // 이렇겐 가능
}
```

```tsx
interface User {
  name: string;
  age: number;
}

interface User2 extends User {
  name: "yaaam"; // 가능!!
}
```

- 다중 인터페이스 확장

여러 인터페이스를 확장할 수 있다. 이용된 인터페이스의 모든 멤버를 가진다. 쉼표로 구분한다.

<br/>

# 7.4 인터페이스 병합

(위에서 미리적었지만) 동일한 이름의 인터페이스가 재선언된경우, 모든 필드를 포함하는 더 큰 인터페이스가 추가된다.

단, 병합시 타입이 다른 동일한 이름의 속성을 여러 번 선언은 안된다!
