# [러닝TS] CH15 타입 운영

<br/>

# 15.1 매핑된 타입

다른 타입의 속성을 기반으로 새로운 **타입을 생성**하는 구문(=매핑)

인덱스 시그니처와 유사한 구문이지만 : 대신 in사용!

```tsx
type Fruits = "Apple" | "Banana" | "Orange";

type MyFruits = {
  [K in Fruits]: number;
};
// type MyFruits = {
//     Apple: number;
//     Banana: number;
//     Orange: number;
// }
```

주로, 유니언 타입에 존재하는 문자열 리터럴 키를 가진 객체 생성시 사용된다!

## 15.1.1 타입에서 매핑된 타입

일반적으로 매핑된 타입은 **존재하는 타입에 keyof 연산자를 사용해 키를 가져오는 방식**으로 작동

키밸류 속성을 가지는 인터페이스의 경우 `keyof` 로 키값을 가져와서!

```tsx
interface Fruits {
  apple: boolean;
  banana: number;
  orange: string;
}
type MyFruits = {
  [K in keyof Fruits]: number;
};
// type MyFruits = {
//     apple: number;
//     banana: number;
//     orange: number;
// }
```

### 매핑된 타입과 시그니처

매핑 구문을 시그니처에도 쓸 수 있다.

```tsx
interface Researcher {
  method(): void;
  property: () => string;
}
type Prop<T> = {
  [K in keyof T]: T[K]; // 매핑타입에 시그니처
};

type properties = Prop<Researcher>;
// type properties = {
//     method: () => void; // 인터페이스에서 메서드 구문과 속성 구문으로 선언한 멤버에 대해 구분하지 않음.
//     property: () => string;
// }
```

## 15.1.2 제한자 변경

원래 타입의 멤버에 대해 접근 제어 제한자인 `readonly` 와 `?` 도 변경 가능하다. 구문 동일

```tsx
interface Fruits {
  apple: boolean;
  banana: number;
  orange: string;
}
type ReadOnlyMyFruits = {
  readonly [K in keyof Fruits]: Fruits[K];
};
// type ReadOnlyMyFruits = {
//     readonly apple: boolean;
//     readonly banana: number;
//     readonly orange: string;
// }
```

### 제한자 제거 `-`

```tsx
interface Fruits {
  apple: boolean;
  readonly banana?: number;
  readonly orange: string;
}
type MyFruits = {
  -readonly [K in keyof Fruits]: Fruits[K];
};
// type MyFruits = {
//     apple: boolean;
//     banana?: number | undefined;
//     orange: string;
// }
```

```jsx
// ? 제거시엔
interface Fruits {
  apple: boolean;
  readonly banana?: number;
  readonly orange: string
}
type MyFruits = {
  [K in keyof Fruits]-?: Fruits[K]
}
// type MyFruits = {
//     apple: boolean;
//     readonly banana: number;
//     readonly orange: string;
// }
```

-readonly [ ~ ]-? 로 두개 동시에도 가능

## 15.1.3 제네릭 매핑된 타입

<br/>

# 15.2 조건부 타입

```jsx
LeftType extends RightType ? IfTure : IfFalse
// 왼쪽 타입이 오른쪽 타입이 되는지(또는 할당 가능한지) 여부 검사.
```

_왼⊂오 개념이려나?_

## 15.2.1 제네릭 조건부 타입

```ts
type check<T> = T extends string ? true : false;

type cs = check<"literal">; // true
```

```ts
type check<T> = T extends "literal" ? true : false;

type cs = check<string>; //false
```

제네릭T 에 대해 함수인지 아닌지 확인하는 로직

```ts
type Callable<T> = T extends () => any ? T : () => T;

type NumberCallable = Callable<() => number[]>; //type NumberCallable = () => number[]

type StringCallable = Callable<string>; //type StringCallable = () => string
```

함수에 제공된 옵션 객체를 기반으로 함수의 반환 타입을 변경하는 것

```ts
interface QueryOptions {
  throwNF: boolean;
}
type QueryResult<Options extends QueryOptions> = Options["throwNF"] extends true
  ? string
  : string | undefined;

declare function retrieve<Options extends QueryOptions>(
  key: string,
  options?: Options
): Promise<QueryResult<Options>>;
```

## 15.2.2 타입 분산

```ts
C<T|U> 는 C<T> | C<U> 와 같다!
```

```tsx
type ArrOrStr<T> = T extends string ? T : T[]; // string 이면 string , 아닌경우엔 string[]

type Half = ArrOrStr<string | number>; //type Half = string | number[]
// ArrOrStr<string> | ArrOrStr<number> 와 같으므로 string | number[] 임!
// (string | number)[] 아님!
```

조건부 타입은 전체 유니언 타입이 아니라 유니언 타입의 각 구성 요소에 로직을 적용함

## 15.2.3 유추된 타입

`infer`

선언되는 위치에서 구조가 일치하는지 판단해야함!

```tsx
type ArrItem<T> = T extends (infer Item)[] ? Item : T; // 배열타입이면 배열 각 타입이 Item이 되는거임. ex string[]이면 Item이 string

type Str = ArrItem<string>; //string
type StrArr = ArrItem<string[]>; // string
type Str2DArr = ArrItem<string[][]>; //string[]
```

재귀적 조건부 타입에도 사용할 수 있다.

```ts
type ArrItemRecursive<T> = T extends (infer Item)[]
  ? ArrItemRecursive<Item>
  : T;

type Str = ArrItemRecursive<string>; //string
type StrArr = ArrItemRecursive<string[]>; // string
type Str2DArr = ArrItemRecursive<string[][]>; //string
// 재귀로 작동해서 두번쨰 재귀에선 string이 Item임
```

## 15.2.4 매핑된 조건부 타입

```ts
type ChangeToFunc<T> = {
  [K in keyof T] : T[K] extends () => any //교재에선 (...args:any[]) => any
  ? T[K]
  : () => T[K]
}

type test = ChangeToFunc<{
  alreadyFunc : () => string,
  notFunc : number,
}
// type test = {
//     alreadyFunc: () => string;
//     notFunc: () => number;
// }
```

<br/>

# 15.3 never

## 15.3.1 never와 교차, 유니언 타입

never: 존재할 수 없는 타입

- TYPE & never === never
- TYPE | nver === TYPE ( never 무시 )

## 15.3.2 never와 조건부 타입

일반적으로 유니언에서 타입을 필터링하기 위해 never 사용

```tsx
type OnlyString<T> = T extends string ? T : never;

type RedOrBlue = OnlyString<"red" | "blue" | 0 | false>;
// type RedOrBlue = "red" | "blue"

type RedOrBlue2 = OnlyString<0 | false>;
// type RedOrBlue2 = never

const a: RedOrBlue = "red";
const b: RedOrBlue = true; // Type 'true' is not assignable to type 'RedOrBlue'.(2322)
const c: RedOrBlue2 = "red"; //Type 'string' is not assignable to type 'never'.(2322)
// c: never
```

제네릭 타입에 대한 타입 유틸리티를 만들 때 유추된 조건부 타입과 결합

```ts
type FirstParam<T extends (...args: any[]) => any> = T extends (
  arg: infer Arg
) => any
  ? Arg
  : never;

type GetsString = FirstParam<(arg0: string) => void>;
// type GetsString = string
```

_T가 함수타입을 만족해야하고, 그때 infer Arg에서 Arg는 string으로 유추되니까 string 타입됨_

> 조건부 타입의 false 결과로 never를 사용하면, FirstParam이 함수의 첫번째 매개변수 타입(string)을 추출할 수 있다!

## 15.3.3 never와 매핑된 타입

다음 세 가지 타입 시스템 기능을 사용해 객체의 키를 필터링합니다.

- 유니언에서 never는 무시
- 매핑된 타입은 타입의 멤버를 매핑할 수 있다.
- 조건부 타입은 조건이 충족되는 경우 타입을 never로 변환하는데 사용할 수 있다.

원래 타입의 각 멤버를 원래 키 또는 never로 변경하는 매핑된 타입 만들기

```tsx
type OnlyStringProp<T> = {
  [K in keyof T]: T[K] extends string ? K : never;
  // 제네릭 T타입의 각 멤버에 대해, 각 멤버의 타입이 string이면 멤버 "키"를 반환, 아니면 never. _리터럴 타입으로 만드는?
  // [K in keyof T] : T[K] extends string ? T[K] : never; 면 type OnlyStringEventData = string
}[keyof T];

interface AllEventData {
  strs: string[];
  loc: string;
  name: string;
  year: number;
}

type OnlyStringEventData = OnlyStringProp<AllEventData>;
//type OnlyStringEventData = "loc" | "name"
```

OnlyStringProp<T> 타입 이해를 요약하자면, “string타입인 속성에 대해서만 각각의 키([keyof T])를 반환”

<br/>

# 15.4 템플릿 리터럴 타입

문자열 타입엔 원시 string 타입과, 리터럴 타입이 있다.

경우에 따라 문자열이 일부 문자열 패턴과 일치함을 나타내기 위해 `템플릿 리터럴 타입` 을 사용한다.

템플릿 리터럴 타입은 템플릿 리터럴 문자열 처럼 보이지만, 추정할 수 있는 원시 타입 또는 원시 타입 유니언이 있다 !!!!

→ **string, number, bigint, boolean, null, undefiend와 같은 모든 원시타입**(symbol제외)과 그 유니언에 대해 허용!!

_문자열에 보간법을 함께 사용하는 형식 같다_

```tsx
type Greeting = `Hello${string}`;

let hi: Greeting = "Hello Hi"; // OK

let outOfOrder: Greeting = "Hi Hello"; // 순서주의! ${string} 위치에 와야함!
//Type '"Hi Hello"' is not assignable to type '`Hello${string}`'.(2322)

let missingHello: Greeting = "Nice to see u"; // ${string} 제외 나머지 문자열 만족해야함!
//Type '"Nice to see u"' is not assignable to type '`Hello${string}`'.(2322)
```

위 예시처럼 템플릿 리터럴 타입을 하나의 원시 타입으로만 사용해야하는건 아니고, 문자열 타입과 그 유니언을 사용하여 더 좁게 제한할 수 있다!

제한된 허용 문자열 집합과 일치해야 하는 문자열 설명에 유용하다!!!!

```tsx
type Brightness = "dark" | "light";
type Color = "blue" | "red";

type BrightAndColor = `${Brightness}-${Color}`;

let colorOk: BrightAndColor = "dark-blue"; // colorOk

let colorWrongOrder: BrightAndColor = "blue-dark";
//Type '"blue-dark"' is not assignable to type '"dark-blue" | "dark-red" | "light-blue" | "light-red"'.(2322)

let colorWrong: BrightAndColor = "hi-hello";
//Type '"hi-hello"' is not assignable to type '"dark-blue" | "dark-red" | "light-blue" | "light-red"'.(2322)
```

## 15.4.1 고유 문자열 조작 타입

문자열을 가져와 문자열에 일부 조작을 적용하는 고유 제네릭 유틸리티 타입이 있다.

```tsx
type ToUpper = Uppercase<"hi">; //type ToUpper = "HI"
type ToLower = Lowercase<"HEllo">; //type ToLower = "hello"

type ToCap = Capitalize<"niCE">; //type ToCap = "NiCE"
// "첫번째" 문자를 대문자로!

type ToUnCap = Uncapitalize<"GoOd">; //type ToUnCap = "goOd"
// "첫번째" 문자를 소문자로!
```

## 15.4.2 템플릿 리터럴 키

템플릿 리터럴 타입은 여전히 문자열이다. 따라서, 문자열 리터럴을 사용할 수 있는 모든 위치에서 사용 가능!

```tsx
type DataKey = "location" | "name" | "year";

type ExistenceCheck = {
  [K in `check${Capitalize<DataKey>}`]: () => boolean;
};
// type ExistenceCheck = {
//     checkLocation: () => boolean;
//     checkName: () => boolean;
//     checkYear: () => boolean;
// }

function checkExistence(checks: ExistenceCheck) {
  checks.checkLocation();
  checks.checkName();
  checks.checkYear();

  checks.checkWrong(); // Property 'checkWrong' does not exist on type 'ExistenceCheck'.(2339)
}
```

## 15.4.3 매핑된 타입 키 다시 매핑하기

템플릿 리터럴 타입을 사용해 원래 멤버를 기반으로 매핑된 타입의 멤버에 대한 새로운 키를 생성할 수 있다.

`as` 키워드를 사용해서, 결과 타입의 키를 템플릿 리터럴 타입과 일치하도록 변경한다.

그러면 매핑된 타입은 원래 값을 참조하면서 각 매핑된 타입 속성에 대한 다른 키를 가질 수 있다.

```tsx
type DataKey = "location" | "name" | "year";

interface DataEntry<T> {
  key: T;
  value: string;
}

type DataEntryFuncBoolean = {
  [K in DataKey]: () => DataEntry<K>; // 기본 매핑
};
// type DataEntryFuncBoolean = {
//     location: () => DataEntry<"location">;
//     name: () => DataEntry<"name">;
//     year: () => DataEntry<"year">;
// }

type DataEntryLiteralMapping = {
  [K in DataKey as `get${Capitalize<K>}`]: () => DataEntry<K>; // 매핑에 리터럴타입으로 다시 매핑
};
// type DataEntryLiteralMapping = {
//     getLocation: () => DataEntry<"location">;
//     getName: () => DataEntry<"name">;
//     getYear: () => DataEntry<"year">;
// }
```

JS에서 객체의 키는 string | Symbol 인데, Symbol키는 템플릿 리터럴 타입으로 사용할 수 없다!

`string & symbol` 은 `never` 임을 사용해서, symbol 타입에 대해 무시하도록 강제한다.

```tsx
const someSymbol = Symbol("");

interface HasStringAndSymbol {
  StringKey: string;
  [someSymbol]: number;
}

type ToGetters<T> = {
  [K in keyof T as `get${string & K}`]: () => T[K];
};

type GettersJustString = ToGetters<HasStringAndSymbol>;
// type GettersJustString = {
//     getStringKey: () => string;
// }
```

<br/>

# 15.5 타입 운영과 복잡성

> 타입 운영을 사용해야 하는 경우에는, 향수 코드를 읽어야 하는 모든 개발자를 위해 가능한 한 최소한으로 사용하도록 노력하세요. 코드를 읽는 사람이 이해하기 쉬운 이름을 사용하고, 미래에 코드를 읽을 때 겪을 수 있다고 생각하는 모든 부분에 설명을 남겨주세요
