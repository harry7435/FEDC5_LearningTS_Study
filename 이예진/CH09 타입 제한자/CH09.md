top 타입 : any, unknown

bottom 타입 : never

<br/>

# 9.1 top 타입 : 시스템에서 가능한 모든 값

## 9.1.1 any

안정성 부족, 타입스크립트 유용성 감소

어떤 값이든 가능함을 나타내고 싶다면 “unknown”이 훨씬 안전

## 9.1.2 unknown

any 보다 조금 더 엄격(제한적)

unknown이나 any가 아닌 타입에 할당할 수 없다!!

<br/>

# 9.2 타입 서술어

인수가 특정 타입인지 여부를 나타내기 위해 boolean 값을 반환하는 함수를 위한 특별한 구문.

`매개변수 **is** 타입`

```tsx
function isNumberOrString(value: unknown) {
  // 이렇게만 두면 이 함수가 value의 타입을 체크하여 boolean을 반환한다는 것을 알 수 없다!
  return ["number", "string"].includes(typeof value);
}
function check(value: number | string | null | undefined) {
  if (isNumberOrString(value)) {
    console.log(value.toString()); // ERROR! 'value' is possibly 'null' or 'undefined'.(18049)
    // 그래서 여기서 value의 타입일 수 있는 null에 의해 에러가 발생!!!
  } else {
    console.log("not exist", value);
  }
}
```

```jsx
**// 이렇게 타입 서술어를 이용하자!!**
function isNumberOrString(value: unknown)**: value is number | string** {
	//
}
```

확장된 인터페이스를 사용할 때, 더 구체적인 인터페이스의 인스턴스인지 검사할 수도 있다.

하지만! 잘못 수행할 수 있기 때문에 피하는 것이좋다.. 간단한 타입 서술어만으로도 충분함^^

<br/>

# 9.3 타입 연산자

기존 타입의 속성 일부를 변환해서 두 타입을 결합할 때

## 9.3.1 keyof

존재하는 타입의 키를 바탕으로 **유니언 타입을 생성**하는 기능

```tsx
interface Ratings {
  audience: number;
  critics: number;
}
function getRating(ratings: Ratings, key: string): number {
  return ratings[key]; // ERROR
  // Element implicitly has an 'any' type because expression of type 'string' can't be used to index type 'Ratings'.
  // No index signature with a parameter of type 'string' was found on type 'Ratings'.(7053)
}
```

이렇게 유효하지 않은 키가 허용되는 에러가 생길 수 있다.

```tsx
function getRating(ratings : Ratings , key: 'audience'| 'critics') : number {
```

이렇게 허용되는 키에 대해 리터럴 유니언 타입을 사용할 수 있지만, 인터페이스가 많은 멤버를 가진다면 번거로운 작업이 된다.

이 때 `keyof` 키워드를 이용하자!

```tsx
function getRating(ratings : Ratings , key: **keyof Ratings**) : number {
```

여기에선 위의 'audience' | ‘critics'와 동일하지만, 훨씬 빠르고, 인터페이스가 변경되어도 수동으로 수정할 필요가 없다.

## 9.3.2 typeof

제공되는 값의 타입을 반환

```tsx
const org = {
  med: "movie",
  title: "mean girls",
};
let adaptation: typeof org;
// let adaptation: {
//     med: string;
//     title: string;
// } // <- org와 내부 속성까지 같은 객체타입!
```

typeof 타입 연산자는 런타임 typeof 연산자와 다르다!

런타임 typeof 연산자는 타입에 대한 문자열 이름을 반환하는 것이고,

타입스크립트의 typeof 타입 연산자는 타입스크립트에서만 사용! JS로 컴파일되지 않음!

## keyof typeof

keyof 는 값의 타입 검색 , typeof는 허용된 키 검색

이 두개를 함께 연결해 값의 타입에 허용된 키를 간결하게 검색 ㅏㄱ능!

```tsx
const ratings = {
  a: 2.0,
  b: 12,
};
function logRatings(key: keyof typeof ratings) {
  // (parameter) key: "a" | "b"
  console.log(key);
}
```

_typeof ratings는 rating 객체와 같은 타입인 { a:2.0 , b:12} 이고 이의 keyof 니까 a | b_

```tsx
const ratings = {
  a: {
    aa: "and",
  },
};
function logRatings(key: keyof typeof ratings) {
  // (parameter) key: "a" | "b"
  console.log(ratings[key]);
}
console.log(ratings["a"]); // OK! // [LOG]: {  "aa": "and" }
```

이것도 OK

<br/>

# 9.4 타입 어서션

타입스크립트는 코드의 모든 값이 정확히 타입화될(정확히 알려질) 때 가장 잘 작동한다.

타입어서션(assertion, 타입 캐스트)는 갑의 타입에 대한 타입 시스템의 이해를 재정의하기 위한 구문.

`as`

```tsx
const dummy = '["a" , "b"]'

const d1 = JSON.parse(dummy) // any
// ["a", "b"]

const d2 = JSON.parse(dummy) **as string[]** //  string[]
console.log(d2) // ["a", "b"]
```

다만, 가능한 한 타입 어서션 사용하지 않는 걸 권장.

## 9.4.1 포착된 오류 타입 어서션

그래도 오류를 처리할 때 타입 어서션이 유용할 수 있음!

try-catch에서 오류가 catch에 포착되었을 때, 만약 Error 클래스의 인스턴스를 발생시키는게 확실하다면,

```tsx
try ..
catch (error){
	console.warn("NO!" , **(error as Error).**message);
}
```

혹은 `instanceof` 검사를 통해 타입 내로잉을 사용하는 것이 더 안전

```tsx
try ..
catch (error){
	console.warn("NO!" , **error instanceof Error** ? error.**.**message : error);
}
```

## 9.4.2 non-null 어서션

또 다른 유용한 경우로, 이론적으로만 null 또는 undefined를 포함할 수 있는 변수에서 null과 undefined를 제거할 때 타입 어서션을 주로 사용

`!` 라는 약어를 사용한다!

```tsx
let maybeDate : Date | undefined 인 상황에서,

maybeDate as Date // Date로 간주
myabeDate**!** // 위와 동일!
```

값이 존재하지 않는 경우 undefined를 반환하는 Map.get 등의 API에서 유용하다!!

```tsx
const data = new Map([
  ["a", "1"],
  ["b", "2"],
]);

data.get("a").toUpperCase(); //Object is possibly 'undefined'.(2532)

data.get("a")!.toUpperCase(); // OK !!
```

## 9.4.3 타입 어서션 주의 사항

any처럼 하나의 도피수단이다. 꼭 필요한 경우가 아니라면 가능한 한 사용하지 말자!

어서션 vs 선언

타입 선언과 초기화가 같이 있을때, 선언된 타입에 대한 초깃값 할당 가능성을 검사한다.

하지만, 어서션은 일부를 건너뛰도록 명시적으로 지시한다.. 이는 런타임에서 오류

어서션 할당 가능성

타입 중 하나가 다른 타입에 할당 가능한 경우메나 두 타입 간의 타입 어서션을 허용.

<br/>

# 9.5 const 어서션

배열의 const 어서션 과 조금은 비슷하다.

const 어서션은 배열, 원시 타입, 값, 별칭 등 모든 값을 **상수**로 취급해야함을 나타낸다.

```tsx
[0, ""] as const; // **readonly** [0, '']
```

as const가 생성하는 다른 두가지 변경 사항을 알아보자

## 9.5.1 리터럴에서 원시 타입으로

```tsx
const getName = () => "guri"; // const getName: () => string

const getNameConst = () => "guri" as const; // const getNameConst: () => "guri"
```

더 구체적인 리터럴 값으로 타입을 인식하게 한다!!

리터럴 타입으로 선언된 멤버에 할당할 때 유용한듯 _이렇게 이해가 맞나_

```tsx
interface Joke {
  quote: string;
  style: "story" | "one-liner";
}
function tellJoke(joke: Joke) {
  if (joke.style === "one-liner") {
    console.log(joke.quote);
  } else {
    console.log(joke.quote.split(" "));
  }
}
const joke1 = {
  quote: "blahblah",
  style: "one-liner" as const, //
};
const joke2 = {
  quote: "muahmuah",
  style: "one-liner",
};

tellJoke(joke1);
tellJoke(joke2); // Joke 타입이어야하는 tellJoke함수의 인자 joke에 할당될 수 없다.
// Argument of type '{ quote: string; style: string; }' is not assignable to parameter of type 'Joke'.
// Types of property 'style' are incompatible.
//   Type 'string' is not assignable to type '"story" | "one-liner"'.(2345)
```

## 9.5.2 읽기 전용 객체

as const를 사용해 값 리터럴을 어서션 하면 유추된 타입이 가능한 한 구체적으로 전환됩니다. 모든 멤버 속성은 readonly가 되고, 리터럴은 일반적인 원시 타입 대신 고유한 리터럴 타입으로 간주되며, 배열은 읽기 전용 튜플이 됩니다. 즉, 값 리터럴에 const 어서션을 적용하면 해당 값 리터럴이 변경되지 않고 모든 멤버에 동일한 const 어서션로직이 재귀적으로 적용됩니다.
