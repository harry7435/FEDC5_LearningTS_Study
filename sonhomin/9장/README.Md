## 9장 타입제한자

### 9.1 top타입

top타입은 시스템에서 가능한 모든 값을 나타내는 타입입니다.

즉, 모든 타입은 top타입에 할당할 수 있습니다.

#### any 다시보기

any타입은 모든 타입의 위치에 제공될 수 있다는 점에서 top타입처럼 작동할 수 있습니다.

다만 어떠한 값이든 될 수 있음을 나타내려면 `unknown`타입이 훨씬 안전합니다

#### 9.1.2 unknown

unknown은 진정한 top타입이다.

모든 객체를 unknown 타입의 위치로 전달할 수 있다는 점에서 any타입과 유사하다.

- 타입스크립트는 unknown 타입 값의 속성에 직접 접근할 수 없다
- top타입이 아닌 타입에는 할당할 수 없다

타입스크립트가 unknown 에 접근할 수 있는 유일한 방법은 instance of나 type of 또는 타입 어서션을 사용하는 것 처럼 값의 타입이 제한된 경우이다.

### 9.2 타입 서술어

내로잉을 위해 instance of , type of 를 사용해 타입을 좁힐 수 있다.

특정타입인지 여부를 나타내기 위해 boolean값을 반환하는 함수를 위한 특별한 구문이 있다. `is`

```ts

function isNumberOrString(value : unknown) : value is number|string {
    ~
}


```

타입서술어는 단순 boolean값을 반환하는것이 아닌 구체적인 타입임을 나타낸다.

타입서술어는 속성이나 값의 타입을 확인하는 것 이상으로 수행하기에 가능하면 피하는것이 좋다.

### 타입연산자

`keyof` 객체에서 키값을 바탕으로 유니언 타입을 생성하는 기능

=> 문제풀면서 많이 사용함

`typeof` 객체에 타입을 지정해주면 Object가 아니라 내부의 타입이 지정됨

타입스크립트에서 typeof와 자바스크립트에서 typeof는 다른연산자이며 어떤 타입인지를 반환할 때 사용하는 연산자와 시각적으로 주어진 값이 어떤 타입인지를 반환하는 타입 연산자는 엄연히 다르다.

```ts
const ratings = {
  a: 123,
  b: 321,
};

function q(key: keyof typeof ratings) {
  // 에서 key의 타입은 a | b 이다.
}
```

### 타입 어서션

강력하게 타입화 될 때 가장 잘 동작한다

as키워드를 사용하며 any타입을 확실하게 지정한다.

다만 타입스크립트는 가능한 타입어서션을 사용하지 않는것이 모범사례이다 , 그러나 유용하고 종종 필요한 경우가 있다.

#### 포착된 오류 타입 어서션

```ts
try {
} catch (err) {
  console.warn("", (err as Error).message);
}
```

발생된 오류가 예상된 오류 타입인지를 확인하기 위해 내로잉을 사용하는것이 더 안전하다.

#### non-null 어서션

실제로는 아니지만 이론적으로 null 또는 undefined를 포함할 수 있는 변수에서 null 및 undefined를 제거할 때 많이 사용한다

```ts
let a =
  Math.random() > 0.5 ? undefined : new Date();

a as Date;

a!;
```

에서 a가 Date 로 간주된다.

!활용 잘해보자

#### 타입 어서션 주의 사항

any타입과 마찬가지로 타입 어서션은 타입스크립트의 타입 시스템에 필요한 하나 수단이다.

non-null 어서션은 타입 검사에서는 오류가 발생하지 않을 수 있지만 런타임 오류는 발생할 수 있다.

어서션은 자주사용하면 안되고 사용하는 것이 안전하다고 확실히 확신할때만 사용해야 한다.

**어서션 vs 선언**

```ts
interface a {
  acts: string[];
  name: string;
}

const b = {
  name: "h0ber",
} as a;

b.acts.join("");
```

와 같은 코드는 동작하지만 런타임시 에러가 발생한다.

194페이지에서 자바스크립트 런타임에서 동작하지 않는다는 얘기인가요 아니면
ts => js 에서 에러가 발생한다는건가요

**어서션 할당 가능성**

`let name = 'h0ber' as number`
하면 허용되지 않는다

왜냐하면 어서션은 하나의 도피처일 뿐이다.

`let name = 'h0ber' as unknown as number`
와 같이 도피해야 한다.
물론 사용하라고 알려준건 아니다

### const 어서션

const 어서션은 모든 값을 상수로 취급해야 함을 나타내는데 사용한다

- 배열은 가변이 아니라 읽기전용 튜플로 취급됩니다
- 리터럴은 일반적인 원시 타입과 동등하지 않고 리터럴로 취급됩니다
- 객체의 속성은 읽기 전용으로 간주됩니다

#### 리터럴에서 원시값으로

타입시스템이 리터럴을 일반적인 원시 타입으로 확장하기보다 특정 리터럴로 이해하는것이 유용할 수 있습니다

#### 읽기전용객체

apple과 같은 문자열은 string과 같은 원시값이 되고 배열은 튜플이 아닌 array타입이 된다.
하지만 리터럴 타입이 필요한 위치에서 사용해야 할 때 잘 맞지않을 수 있다.

그러나 as const를 사용해 값 리터럴을 어서션하면 유추된 타입이 가능한 구체적으러 전환된다.

배열은 읽기전용 튜플이 되며 모든 멤버 속성은 readonly가 된다.

객체에서 as const 어서션을 적용하면 readonly로 변하며 재할당이 불가능해진다.
