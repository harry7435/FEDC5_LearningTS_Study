# 4장 객체

## 4.1 객체 타입

객체 타입은 객체 리터럴과 유사하게 보이지만 필드 값 대신 타입을 사용해 설명한다. 

## 4.2 구조적 타이핑

타입스크립트의 타입 시스템은 구조적으로 타입화되어 있다. 매개변수나 변수가 특정 객체 타입으로 선언되면 타입스크립트에 어떤 객체를 사용하든 해당 속성이 있어야 한다고 말해야 한다.

타입스크립트의 타입 검사기에서 구조적 타이핑은 정적 시스템이 파일을 검사하는 경우이고, 덕 타이이핑은 런타임에서 사용될 때까지 객체 타입을 검사하지 않는 것이다.

### 사용 검사

타입스크립트는 값을 해당 객체 타입에 할당할 수 있는지 확인할 때, 할당하는 값에는 객체 타입의 필수 속성이 있어야 한다. 객체 타입에 필요한 프로퍼티가 객체에 없거나 타입이 일치하지 않는 경우 타입스크립트는 타입 오류를 발생시킨다.

### 초과 속성 검사

변수가 객체 타입으로 선언되고, 초깃값에 객체 타입애서 정의된 것보다 많은 필드가 있다면 타입스크립트에서 타입 오류가 발생한다. 변수를 객체 타입으로 선언하는 것은 타입 검사기가 해당 타입에 예상되는 필드만 있는지 확인하는 방법이기도 하다.

### 중첩된 객체 타입

중첩된 타입을 자체 별치이 객체 타입으로 추출할 수 있다. 중첩된 객체 타입을 고유한 타입 이름으로 바꿔서 사용하면 코드와 오류 메시지가 더 읽기 쉬워진다는 장점이 있다.

## 4.3 객체 타입 유니언

### 유추된 객체 타입 유니언

변수에 여러 객체 타입 중 하나가 될 수 있는 초기값이 주어지면 타입스크립트는 해당 타입을 객체 타입 유니언으로 유추한다. 유니언 타입은 가능한 각 객체 타입을 구성하고 있는 요소를 모두 가질 수 있다.

### 명시된 객체 타입 유니언

객체 타입의 조합을 명시하면 객체 타입을 더 명확히 정의할 수 있기 때문에 객체 타입을 더 많이 제어할 수 있는 이점이 있다. 특히 값의 타입이 객체 타입으로 구성된 유니언이라면 유니언 타입에 존재하는 속성에 대한 접근만 허용한다. 잠재적으로 존재하지 않는 객체의 프로퍼티에 대한 접근을 제한하면 코드의 안전을 지킬 수 있다.

### 객체 타입 내로잉

타입 검사기가 유니언 타입 값에 특정 속성이 포함된 경우에만 코드 영역을 실행할 수 있음을 알게 되면, 값의 타입을 해당 속성을 포함하는 구성 요소로만 좁힌다. 코드에서 객체의 형태를 확인하고 타입 내로잉이 객체에 적용된다.

```js
// in 연산자로 true/false 확인
if("pages" in poem){
  poem.pages;
} else{
  poem.rhymes;
};
```

### 판별된 유니언

자바스크립트와 타입스크립트에서 유니언 타입으로 된 객체의 또 다른 형태는 객체의 속성이 객체의 형태를 나타내도록 하는 것이다. 이러한 타입 형태를 판별된 유니언이라고 하고, 객체의 타입을 가리키는 속성이 판별값이다.

```js
type PomeWithPages = {
    name: string;
    number: number
    type: 'pages';
}

type PoemWithRhymes = {
    name: string;
    rhymes: boolean;
    type: 'rhymes';
}

type Poem = PoemWithPages | PoemWithRhymes;

const poem: Poem = Math.random > 0.5 
	? { name: "The Double Image", pages: 7, type: "pages" }
	: { name: "Her Kind", rhymes: true, type: "rhymes" };

if(poem.type === "pages"){
   // PoemWithPages 타입
}else{
   // PoemWithRhymes 타입  
}
```

`Poem` 타입은 `type` 속성(프로퍼티)로 어느 타입인지를 나타낸다. 타입 내료잉 없이는 값에 존재하는 속성을 보장할 수 없다.

## 4.4 교차 타입

타입스크립트에서도 교차 타입 `&`을 사용해 여러 타입을 동시에 나타낼 수 있다.
교차 타입은 여러 기존 객체 타입을 별칭 객체 타입으로 결합해 새로운 타입을 생성한다. 교차 타입은 유니언 타입과도 결합할 수 있다.

### 교차 타입의 위험성

- 긴 할당 가능성 오류 : 교차 타입이 복잡할수록 할당 가능성 오류 메시지는 읽기 어려워진다.

- never : 원시 타입의 값은 동시에 여러 타입이 될 수 없기 때문에 교차 타입의 구성 요소로 함께 결합할 수 없다.

```ts
type NotPossible = number & string; // never
```