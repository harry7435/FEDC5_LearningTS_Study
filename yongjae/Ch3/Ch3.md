## Chapter3. 유니언과 리터럴

TS가 타입 추론을 수행하는 핵심 개념

- `유니언` : 값에 허용된 타입을 두 개이상의 가능한 타입으로 확장하는 것
- `내로잉`: 값에 허용된 타입이 하나 이상의 가능한 타입이 되지 않도록 좁히는 것

### 유니언 타입

`유니언 타입`은 값이 정확히 어떤 타입인지 모르지만, **두 개 이상의 타입 중 하나**라는 것을 나타낸다

- 형식 : (타입) | (타입) | ...

```ts
let mathematician: string | undefined;
```

#### 유니언 타입 선언

변수의 초기값이 있더라도 변수에 대한 `명시적 타입 애너테이션`을 제공하는 것이 유용할 때 `유니언 타입 선언`을 사용 한다
타입 애너테이션으로 선언하는 모든 곳에서 사용 가능

#### 유니언 속성

`유니언 타입`일 때 TS는 유니언으로 선언한 **모든 타입**에 존재하는 멤버 속성에만 접근할 수 있다.
이는 TS의 안전 조치로, 객체가 어떤 속성을 포함한 타입으로 확실하게 알려지지 않은 경우 해당 속성을 사용하려고 시도하는 것이 안전하지 않다고 여긴다.
유니언 타입으로 정의한 타입 중 **하나의 타입의** 속성을 사용하려면 `내로잉`을 해야한다

### 내로잉

`내로잉` : 값이 이전에 정의된 타입보다 더 구체적인 타입임을 코드에서 유추하는 것
`타입 가드` : 타입을 좁히는 데 사용할 수 있는 논리적 검사

흔히 사용하는 타입 가드

- 값 할당을 통한 내로잉
  : 변수에 값을 할당하면 해당 값의 타입으로 변수의 타입을 좁힌다
- 조건 검사를 통한 내로잉
  변수가 알려진 값과 같은지 확인하는 if문을 통해 변수의 타입을 좁힌다
- typeof 검사를 통한 내로잉
  typeof 연산자를 if문에서 사용해 변수의 타입을 좁힌다

### 리터럴 타입

`리터럴 타입`: 특정 원시값으로 알려진 타입
const로 선언된 변수에 리터럴 값을 할당하면 TS는 자동으로 해당 변수를 할당된 리터럴 값으로 유추한다

```ts
const studyName = "스타디이";
// const studyName : '스타디이';
```

`유니언 타입 애너테이션`에서 `리터럴 타입`과 `원시 타입`을 섞어서 사용 가능하다

```ts
let lifespan: number | "ongoing" | "uncertain";
```

### 엄격한 null 검사

> `십억 달러의 실수` : 다른 타입이 필요한 위치에 `null`값을 사용하도록 허용하는 많은 타입 시스템을 가리키는 업계 용어
> `엄격한 null 검사`가 없는 언어에서는 특정 타입 변수에 null을 할당하는 것이 가능

```ts
const firstName: string = null;
```

TS에서는 tsconfig 설정을 통해 `엄격한 null 검사`를 설정할 수 있다.
일반적으로 엄격한 null 검사를 활성화하는 것을 권장

### 타입 별칭

`타입 별칭`: 재사용하는 타입에 더 쉬운 이름을 할당하는 법

- 형식 : type (새로운 이름) = (타입)
- 편의상 `파스칼 케이스`로 이름 지정
  타입 별칭은 해당 별칭이 참조하는 실제 타입을 입력한 것과 같이 동작한다

```ts
type RawData = boolean | number | string | null | undefined;

let rawDataFirst: RawData;
let rawDataSecond: RawData;
```

- 타입 별칭은 JS로 컴파일되지 않는다.
  타입 시스템에만 존재하기 때문에 런타임에 `타입 별칭`을 참조할 수 없고 오류가 발생한다
- 타입 별칭은 다른 타입 별칭을 참조할 수 있다

```ts
type Id = number | string;
type IdMaybe = Id | undefined | null;
```
