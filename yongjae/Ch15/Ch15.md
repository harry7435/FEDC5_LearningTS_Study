# Chapter 15.

## 15.1 매핑된 타입

**매핑된 타입**이란

> 다른 타입을 가져와서 해당 타입의 속성을 이용해 새로운 타입을 생성한 것

- 기본 구문

```ts
type NewType = {
  [K in OriginalType]: NewProperty;
};
```

- 일반적으로 `keyof` 연산자를 이용해서 기존 타입의 키를 가져온다

```ts
interface AnimalVariants {
  alligator: boolean;
  baboon: string;
  cat: number;
}

type AnimalCounts = {
  [K in keyof AnimalVariants]: AnimalVariants[K] | null;
};
```

- 매핑된 타입에서는 인터페이스의 메서드와 속성 구문을 구분하지 않는다
  - 메서드도 타입의 속성으로 취급한다

> cf)
>
> - `member(): void` 메서드 구문
> - `member: () => void` 속성 구문

- 기존 타입 멤버에 대한 접근 제어 제한자 (`readonly`, `?`)를 변경할 수 있다

  - 제한자 추가
  - 제한자 제거
    - 제한자 앞에 `-` 를 추가
    - `-readonly`, `-?`

- 매핑된 타입을 제네릭과 결합하여 **단일 타입 매핑을 재사용**할 수 있게 한다

```ts
type MakeReadonly<T> = {
  readonly [K in keyof T]: T[K];
};
```

## 15.2 조건부 타입

**조건부 타입**이란

> 기존 타입을 바탕으로 두 가지 가능한 타입 중 하나로 확인되는 타입

- 기본 구문

```ts
AType extends BType ? IfTrue : IfFalse
```

- 논리검사 (`Atype extends Btype`): Atype이 Btype과 동일한지 or 할당 가능한지 여부를 확인

- 제네릭 조건부 타입

```ts
type CheckAgainstNumber<T> = T extends number ? true : false;

type Callable<T> = {
  T extends () => any ? T : () => T;
}
```

- 타입 분산
  - 조건부 타입에 **유니언 타입**이 포함되면 타입이 `분산`된다
  - 유니언 타입의 구성요소에 각각 로직을 적용한다.
  - 결과 타입 : 분산된 조건부 타입의 유니언 타입

```ts
type Example<T> = T extends string ? T : T[];
type UnionExample = Example<string | number>;
// = Example<string> | Example<number>
// = string | number[]
```

- 유추된 타입
  - 제공된 타입의 멤버가 아닌 함수의 매개변수 or 반환 타입 등 정보를 명확히 알 수 없는 경우에 접근하고자 할 때 유추된 타입을 적용한다.
  - 조건부 타입의 extends 절에 `infer`키워드를 사용한다

```ts
type ArrayItems<T> = {
  T extends (infer Item)[] ? Item : T;
}
```

- 유추된 타입 응용 : 재귀적 조건부 타입

```ts
type ArrayItemsRecursive<T> = {
  T extends (infer Item)[] ? ArrayItemsRecursive<Item> : T;
};

ArrayItemsRecursive<string> // string
ArrayItemsRecursive<string[]> // string
ArrayItemsRecursive<string[][]> // string
```

### 매핑된 조건부 타입

매핑된 타입 + 조건부 타입을 사용하여 제네릭 템플릿 타입의 모든 멤버를 매핑하면서 각 멤버에 조건부 로직을 적용할 수 있다

```ts
type MakeAllMembersFunctions<T> = {
  [K in keyof T]: T[K] extends (...args: any[]) => any ? T[K] : () => T[K];
};
```

## 15.3 never

**never**

- bottom 타입
- 존재할 수 없는 타입이라는 의미
- never와 &, |

  - `never & A` // never
  - `never | A` // A

- never와 조건부 타입
  - 제네릭 조건부 타입은 일반적으로 유니언에서 타입을 필터링하기 위해 never을 사용 (never는 유니언에서 무시되니까)
  - infer가 있는 타입 추론은 조건부 타입이 true가 되어야 하므로, never 사용하여 false인 경우를 절대 사용하지 않게 한다

```ts
// 유니언 타입에서 필터링
type OnlyStrings<T> = T extends string ? T : never;
type RedOrBlue = OnlyStrings<"red" | "blue" | 0 | false>;

// infer 타입 추론
type FirstParameter<T extends (...args: any[]) => any> = T extends (
  arg: infer Arg
) => any
  ? Arg
  : never;

type GetsString = FirstParameter<(arg0: string) => void>;
// string
```

## 15.4 템플릿 리터럴 타입

**일부 문자열 패턴을 비교**할 때 사용

- 템플릿 리터럴 타입을 더 좁은 문자열 패턴으로 제한하기
  - string 원시 타입 대신 문자열 리터럴 타입과 그 유니언을 타입 보간법에 사용할 수 있다
  - => 템플릿 리터럴 타입은 제한된 허용 문자열 집합과 일치해야 하는 문자열을 나타내는 데 유용

```ts
type Brightness = "dark" | "light";
type Color = "blue" | "red";

type BrightnessAndColor = "${Brightness}-${Color}";
"dark-red" | "light-red" | "dark-blue" | "light-blue";
```

- 고유 문자열 조작 타입

  - TS에서 문자열 조작 제네릭 유틸리티 타입 제공
  - Uppercase : 문자열 리터럴 타입을 대문자로 변환
  - Lowercase : 문자열 리터럴 타입을 소문자로 변환
  - Capitalize : 문자열 리터럴 타입의 첫 번째 문자를 대문자로 변환
  - Uncapitalize : 문자열 리터럴 타입의 첫 번째 문자를 소문자로 변환

- 템플릿 리터럴 키
  - 템플릿 리터럴은 문자열 리터럴을 사용할 수 있는 모든 곳에서 사용 가능

```ts
type DataKey = "location" | "name" | "year";
type ExistenceCheck = {
  [K in `check${Capitalize<DataKey>}`]: () => boolean;
};

// checkLocation: () => boolean;
// checkName: () => boolean;
// checkYear: () => boolean;
```

- 주의 사항
  - JS에서 객체 키는 string or Symbol이 될 수 있다
  - Symbol은 원시 타입이 아니므로 템플릿 리터럴 타입으로 사용할 수 없다
  - 따라서 제네릭 타입에서 매핑된 템플릿 리터럴 키를 사용하려고 하면 TS 오류 발생

```ts
type TurnintoGettersDirect<T> = {
  [K in keyof T as `get${K}`]: () => T[K];
};
// error
```

이를 방지하기 위해 `string`, `&`을 사용하여 문자열이 될 수 있는 타입만 사용하도록 강제해야 함

- `string & symbol`은 `never`가 되므로 전체 템플릿 문자열은 `never`가 되고 타입스크립트는 이를 무시한다

```ts
type TurnIntoGetters<T> = {
  [K in keyof T as `get${string & K}`]: () => T[K];
};
```
